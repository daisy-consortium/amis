# This script generates a Python interface for an Apple Macintosh Manager.
# It uses the "bgen" package to generate C code.
# The function specifications are generated by scanning the mamager's header file,
# using the "scantools" package (customized for this particular manager).

from bgen import *
from bgenCxxSupport import *
# Declarations that change for each manager
MODNAME = 'amiscore'                         # The name of the module

# The following is *usually* unchanged but may still require tuning
MODPREFIX = 'PyAm'                        # The prefix for module-wide routines
INPUTFILE = 'amiscoregen.py' # The file generated by the scanner
PY2CXXFILE = MODNAME + "module.cpp"       # The Python to C++ glue code
CXX2PYFILE = MODNAME + "interface.cpp"   # The C++ to Python glue code
CXX2PYDECLFILE = MODNAME + "interface.h"     # The C++ to Python declarations

# Create the type objects

includestuff = """
"""
execfile("amiscoreincludegen.py")
includestuff = includestuff + """
/* Workaround for "const" added in Python 2.5. But removed before 2.5a1? */
#if PY_VERSION_HEX >= 0x02050000 && PY_VERSION_HEX < 0x020500a1
# define Py_KEYWORDS_STRING_TYPE const char
#else
# define Py_KEYWORDS_STRING_TYPE char
#endif

#include "amiscoremodule.h"

static PyObject *
bool_New(bool itself)
{
    if (itself) {
        Py_RETURN_TRUE;
    } 
    Py_RETURN_FALSE;
}

static int
bool_Convert(PyObject *v, bool *p_itself)
{
    int istrue = PyObject_IsTrue(v);
    if (istrue < 0) return 0;
    *p_itself = (istrue > 0);
    return 1;
}

PyObject *
ambulant_url_New(const ambulant::net::url& itself)
{
    return PyString_FromString(itself.get_url().c_str());
}

int
ambulant_url_Convert(PyObject *v, ambulant::net::url *p_itself)
{
    char *cstr = PyString_AsString(v);
    if (cstr == NULL) return 0;
    std::string cxxstr = cstr;
    ambulant::net::url url = ambulant::net::url::from_url(cxxstr);
    *p_itself = url;
    return 1;
}
"""

finalstuff = """

// Declare initamiscore as a C external:

extern "C" void initamiscore(); 
"""

initstuff = """
PyEval_InitThreads();
"""

variablestuff="""
"""

print "=== Defining simple types ==="

bool = OpaqueByValueType("bool", "bool")
size_t = Type("size_t", "l")
unsigned_int = Type("unsigned int", "l")
std_string = StdStringType()
string = std_string
const_string = StdStringType("const std::string")
wstring = StdStringType("std::wstring", "wchar_t", "u")

MediaNodeType = Type("amis::MediaNodeType", "l")
ModuleType = Type("amis::ModuleDescData::ModuleType", "l")
amis_ModuleDescData_ModuleType = ModuleType
TextDirection = Type("amis::TextDirection", "l")
TypeOfNode = Type("amis::dtb::nav::NavNode::TypeOfNode", "l")
amis_dtb_nav_NavNode_TypeOfNode = TypeOfNode

amis_ErrorCode = Type("amis::ErrorCode", "l")
##xml_string = StdStringType("ambulant::lib::xml_string")
##const_xml_string_ref = StdStringType("const ambulant::lib::xml_string&")
##q_name_pair = StdPairType(xml_string, xml_string, "ambulant::lib::q_name_pair")
##const_q_name_pair_ref = StdPairType(xml_string, xml_string, 
##    "const ambulant::lib::q_name_pair&", "ambulant::lib::q_name_pair")
##duration = StdPairType(bool, double, "ambulant::common::duration")

##InBuffer = VarInputBufferType('char', 'size_t', 'l')
##return_stringptr = Type("const char *", "z")  # ONLY FOR RETURN VALUES!! May be None/NULL.
# output_stringptr = Type("char *", "s")  # BE CAREFUL!
##output_malloc_buf = MallocHeapOutputBufferType("char", "size_t", "l")

# Ambulant-specific
##q_attributes_list = OpaqueByRefType("ambulant::lib::q_attributes_list", "ambulant_attributes_list")
##region_dim = OpaqueByRefType("ambulant::common::region_dim", "ambulant_region_dim")

pycobject = OpaqueByValueType("void*", "cobject")
ambulant_net_url = OpaqueByRefType("ambulant::net::url", "ambulant_url")
ambulant_net_url_ptr = OpaqueByValueType("ambulant::net::url*", "ambulant_url")
const_ambulant_net_url_ptr = OpaqueByValueType("const ambulant::net::url*", "ambulant_url")

# Our (opaque) objects
class MyGlobalObjectDefinition(CxxMixin, PEP253Mixin, GlobalObjectDefinition):

    def __init__(self, name, prefix, itselftype):
        GlobalObjectDefinition.__init__(self, name, prefix, itselftype)
        self.constructors = []
        
    def add(self, g, dupcheck=0):
        if g.name == self.name:
            g.setselftype(self.objecttype, self.itselftype)
            self.constructors.append(g)
            print "Adding constructor for", self.name
        else:
            GlobalObjectDefinition.add(self, g, dupcheck)
            
    def outputCheckNewArg(self):
        Output('if (itself == NULL)')
        OutLbrace()
        Output('Py_INCREF(Py_None);')
        Output('return Py_None;')
        OutRbrace()
        CxxMixin.outputCheckNewArg(self)
        # XXX Add refcount, if needed
        
    def outputCheckConvertArg(self):
        Output('if (v == Py_None)')
        OutLbrace()
        Output('*p_itself = NULL;')
        Output('return 1;')
        OutRbrace()
        CxxMixin.outputCheckConvertArg(self)
        
    def outputStructMembers(self):
##        Output("void *ob_dummy_wrapper; // Overlays bridge object storage")
        GlobalObjectDefinition.outputStructMembers(self)
        # XXX Output("bool owned;")
        
    def outputInitStructMembers(self):
##        Output("it->ob_dummy_wrapper = NULL; // XXXX Should be done in base class")
        GlobalObjectDefinition.outputInitStructMembers(self)
        # XXX init owned, if needed
        
    def outputCleanupStructMembers(self):
        # XXX For refcounted objects decref
        # XXX For owned objects delete
        pass

    def outputCompare(self):
        Output()
        Output("static int %s_compare(%s *self, %s *other)", self.prefix, self.objecttype, self.objecttype)
        OutLbrace()
        Output("if ( self->ob_itself > other->ob_itself ) return 1;")
        Output("if ( self->ob_itself < other->ob_itself ) return -1;")
        Output("return 0;")
        OutRbrace()

    def outputHash(self):
        Output()
        Output("static int %s_hash(%s *self)", self.prefix, self.objecttype)
        OutLbrace()
        Output("return (int)self->ob_itself;")
        OutRbrace()

    def output_tp_newBody(self):
        Output("PyObject *_self;")
        Output()
        Output("if ((_self = type->tp_alloc(type, 0)) == NULL) return NULL;")
        Output("((%s *)_self)->ob_itself = NULL;", self.objecttype)
        ##Output("((%s *)self)->ob_freeit = CFRelease;", self.objecttype)
        Output("return _self;")

    def output_tp_initBody(self):
        Output("%s itself;", self.itselftype)
        Output("Py_KEYWORDS_STRING_TYPE *kw[] = {\"itself\", 0};")
        Output()
        for con in self.constructors:
            con.outputConstructorBody()
        Output("if (PyArg_ParseTupleAndKeywords(_args, _kwds, \"O&\", kw, %s_Convert, &itself))",
                self.prefix)
        OutLbrace()
        Output("((%s *)_self)->ob_itself = itself;", self.objecttype)
        Output("return 0;")
        OutRbrace()
        Output("return -1;")
        
# Create the generator groups and link them
module = CxxModule(MODNAME, MODPREFIX, includestuff, finalstuff, initstuff, variablestuff)
functions = []

# Start with adding the bridging base class
##pycppbridge = MyBridgeObjectDefinition("pycppbridge", "pycppbridge")
##module.addobject(pycppbridge)

print "=== generating object definitions ==="

execfile("amiscoreobjgen.py")

print "=== declaring more types ==="

# XXXX Temporarily disabled

##audio_format = TupleType("ambulant::net::audio_format",
##        (std_string, "mime_type"),
##        (std_string, "name"),
##        (FakeType("(void *)0"), "parameters"),
##        (int, "samplerate"),
##        (int, "channels"),
##        (int, "bits"))

print "=== Testing availability of support for all needed C types ==="

# Do the type tests
execfile("amiscoretypetest.py")

print "=== Populating method and function lists ==="

class AllowThreadMixin:
    def beginallowthreads(self):
        Output("PyThreadState *_save = PyEval_SaveThread();")
        
    def endallowthreads(self):
        Output("PyEval_RestoreThread(_save);")
        
class Function(AllowThreadMixin, FunctionGenerator):
    pass
class Method(AllowThreadMixin, CxxMethodGenerator):
    pass
ConstMethod = Method
ConstructorMethod = CxxConstructorGenerator

# Create and populate the lists

execfile(INPUTFILE)

print "=== Adding methods to objects, resolving duplicates ==="

# add the populated lists to the generator groups
# (in a different wordl the scan program would generate this)
for f in functions: module.add(f)

for name, object in locals().items():
    if name[-7:] == '_object':
        methodlist_name = 'methods_' + name[:-7]
        methodlist = locals()[methodlist_name]
        for f in methodlist:
            object.add(f)

# Resolve duplicates
module.resolveduplicates()

# ADD add forloop here

print "=== Generating Python->C++ interface module ==="

# generate output (open the output file as late as possible)
SetOutputFileName(PY2CXXFILE)
module.generate()

